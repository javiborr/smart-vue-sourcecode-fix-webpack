
/* Smart HTML Elements v6.1.0 (2020-Jan) 
Copyright (c) 2011-2020 jQWidgets. 
License: https://htmlelements.com/license/ */

Smart.Utilities.Assign('Grid.Edit', class Edit {
    _renderCommandBar() {
        const that = this;

        //const commandBar = that.$.headerCommandBar;
        const dataSource = that.editing.commandBar.dataSource;

        const renderCommandBar = (commandBar) => {
            for (let item in dataSource) {
                const properties = dataSource[item];
                const commandBarItem = document.createElement('div');

                commandBarItem.classList.add('smart-grid-command-item');

                commandBarItem.label = that.localize(item);

                if (properties.icon) {
                    commandBarItem.innerHTML = '<span class="smart-grid-icon ' + properties.icon + '"></span>' + '<span class="smart-grid-label">' + commandBarItem.label + '</span>';
                }

                if (!properties.visible) {
                    commandBarItem.classList.add('smart-hidden');
                }

                commandBarItem.command = properties.command;

                commandBarItem.onclick = function () {
                    const command = commandBarItem.command;

                    that._applyCommand(command, []);
                }

                commandBar.appendChild(commandBarItem);
            }
        }


        if (that.editing.enabled && that.editing.commandBar.visible) {
            that.$.headerCommandBar.innerHTML = '';
            that.$.footerCommandBar.innerHTML = '';

            if (that.editing.commandBar.position !== 'far') {
                renderCommandBar(that.$.headerCommandBar);
            }

            if (that.editing.commandBar.position !== 'near') {
                renderCommandBar(that.$.footerCommandBar);
            }
        }
    }

    commandKeyEditCommand() {
        const that = this;

        if (that._selection && that._selection.focusedCell && that._selection.focusedCell.row) {
            const row = that._selection.focusedCell.row;

            that.beginEdit(row.id);
        }
    }

    commandKeyCancelCommand() {
        const that = this;

        that.cancelEdit();
    }

    commandKeyUpdateCommand() {
        const that = this;

        that.endEdit();
    }

    commandColumnMenuCommand() {
        const that = this;

        that._openColumnChooserMenu(that._commandColumn);
    }

    commandColumnEditCommand(row) {
        const that = this;

        that.beginEdit(row.id);
    }

    commandColumnUpdateCommand(/*row*/) {
        const that = this;

        that.endEdit();
    }

    commandColumnRowMenuCommand(/*row*/) {
        //const that = this;

    }

    commandColumnCancelCommand(row) {
        const that = this;

        if (that.editing.batch) {
            const rowIndex = that._rowsDeleted ? that._rowsDeleted.indexOf(row) : -1;

            if (rowIndex >= 0) {
                that._rowsDeleted.splice(rowIndex, 1);
            }

            for (let i = 0; i < that.columns.length; i++) {
                const dataField = that.columns[i].dataField;

                if (that._cellsUpdatedValues && that._cellsUpdatedValues[row.id + '_' + dataField]) {
                    delete that._cellsUpdatedValues[row.id + '_' + dataField];
                    that._cellsUpdatedValues.length--;
                }
            }
            that._recycle(false);
        }

        that.cancelEdit();
    }

    commandColumnDeleteCommand(row) {
        const that = this;

        that.deleteRow(row.id);
    }

    _renderAddNewRow() {
        const that = this;

        that._frozenNearDefaultRows = [];
        that._frozenFarDefaultRows = [];

        const newNearRow = new Smart.Grid.Row({ data: {}, index: -1, grid: that, freeze: 'near', visible: that.editing.addNewRow.position !== 'far', autoGenerated: true, addNewRow: true });
        const newFarRow = new Smart.Grid.Row({ data: {}, index: -2, grid: that, freeze: 'far', visible: that.editing.addNewRow.position !== 'near', autoGenerated: true, addNewRow: true });

        if (that._newNearRow) {
            const index = that._frozenNearRows.indexOf(that._newNearRow);

            if (index >= 0) {
                that._frozenNearRows.splice(index, 1);

                if (that.$.rowNearContainer.children.length > 0) {
                    const firstChild = that.$.rowNearContainer.children[0];

                    firstChild.parentNode.removeChild(firstChild);
                }
            }
        }

        if (that._newFarRow) {
            const index = that._frozenFarRows.indexOf(that._newFarRow);

            if (index >= 0) {
                that._frozenFarRows.splice(index, 1);

                if (that.$.rowFarContainer.children.length > 0) {
                    const lastChild = that.$.rowFarContainer.children[that.$.rowFarContainer.children.length - 1];

                    lastChild.parentNode.removeChild(lastChild);
                }
            }
        }

        if (that.editing.addNewRow.visible) {
            that._frozenNearDefaultRows.push(newNearRow);
            that._frozenFarDefaultRows.push(newFarRow);

            that._frozenNearRows.splice(0, 0, newNearRow);
            that._frozenFarRows.push(newFarRow);
        }

		if (that._scrollView.vScrollBar.$.farButton) {
			that._scrollView.vScrollBar.$.farButton.addEventListener('click', function () {
				if (that.editing.addNewRow.autoCreate) {
					if (that._scrollView.vScrollBar.value === that._scrollView.vScrollBar.max) {
						that.addUnboundRow(1);

						that._scrollView.vScrollBar.value = that._scrollView.vScrollBar.max;
					}
				}
			});
		}

        that._newNearRow = newNearRow;
        that._newFarRow = newFarRow;

        if (that.editing.addNewRow.visible) {
            if (!that._newNearRow.element) {
                const row = that._newNearRow;
                const element = row.createElement();

                row.visible = that.editing.addNewRow.position !== 'far';
                row.element = element;
                if (that.$.rowNearContainer.children.length > 0) {
                    that.$.rowNearContainer.insertBefore(element, that.$.rowNearContainer.children[0]);
                }
                else {
                    that.$.rowNearContainer.appendChild(element);
                }
            }

            if (!that._newFarRow.element) {
                const row = that._newFarRow;
                const element = row.createElement();

                row.visible = that.editing.addNewRow.position !== 'near';
                row.element = element;
                if (that.$.rowFarContainer.children.length > 0) {
                    that.$.rowFarContainer.insertBefore(element, that.$.rowFarContainer.children[0]);
                }
                else {
                    that.$.rowFarContainer.appendChild(element);
                }
            }
        }
    }

    _insertNewRowAfter(callback) {
        const that = this;

        return that._insertNewRowBefore(callback, true);
    }

    _insertNewRowBefore(callback, insertAtBottom) {
        const that = this;
        const row = new Smart.Grid.Row({ index: insertAtBottom ? 0 : -1, id: Smart.Utilities.Core.createGUID(), grid: that });

        const command = function (row, insertAtBottom) {
            if (that.editing.batch === true || (that.editing.batch && that.editing.batch.indexOf('add') >= 0)) {
                that._batchAddRow(row, insertAtBottom ? that.rows.length : 0);
            }
            else {
                row.index = that.rows.length;
                that._add(row, insertAtBottom ? that.rows.length : 0);
            }

            if (insertAtBottom) {
                that.scrollTop = that.scrollHeight;
            }
            else {
                that.scrollTop = 0;
            }

            if (!that.editing.addDialog.enabled) {
                setTimeout(function () {
                    if (that.editing.enabled) {
                        that._beginEdit(row);
                    }
                }, 100);
            }

            if (callback) {
                callback(row);
            }
        }.bind(this);

        if (that.editing.addDialog.enabled) {
            that._openAddRowDialog(row, command);
        }
        else {
            command(row, insertAtBottom);
        }

        return true;
    }

    commandBarBatchSaveCommand() {
        const that = this;

        that._saveBatchEdit();
    }

    commandBarAddRowCommand() {
        const that = this;

        that._insertNewRowAfter();
    }

    commandBarAddTopRowCommand() {
        const that = this;

        that._insertNewRowBefore();
    }

    commandBarDeleteRowCommand() {
        const that = this;

        let index = 1;
        let rowToDelete = that.rows[that.rows.length - index];

        if (!that._rowsDeleted) {
            that._rowsDeleted = [];
        }

        while (that._rowsDeleted.indexOf(that.rows[that.rows.length - index]) >= 0) {
            index++;
        }

        rowToDelete = that.rows[that.rows.length - index];

        if (rowToDelete) {
            that.commandColumnDeleteCommand(rowToDelete);
        }
    }


    commandBarBatchRevertCommand() {
        const that = this;

        that.revertBatchEdit();
    }

    _beginEdit(row, dataField) {
        const that = this;

        if (!dataField) {
            dataField = that.columns[0].dataField;
        }

        const column = that.columnByDataField[dataField];

        if (that.editing.allowColumnHeaderEdit && !row && column) {
            that._beginColumnEdit(column);

            return;
        }

        if (!row || !column || (column && column.autoGenerated)) {
            return false;
        }

        const cell = row.getCell(dataField);

        if (!cell) {
            return false;
        }

        if (that.editing.mode === 'cell') {
            that._beginCellEdit(cell);
        }
        else if (that.editing.mode === 'row') {
            that._beginRowEdit(row, cell);
        }

        that.$.fireEvent('beginEdit', {
            'row': row,
            'column': column,
            'cell': cell
        });
    }

    _saveUnboundRows(id) {
        const that = this;

        if (that._unboundRows && that._unboundRows.length > 0 && that.editing.addNewRow.autoSave) {
            const row = that.rowById[id];
            if (!row.unbound) {
                return;
            }

            const index = that._unboundRows.indexOf(row);

            if (index < 0) {
                return;
            }

            const length = index + 1;
            that.beginUpdate();

            for (let i = 0; i < length; i++) {
                const row = that._unboundRows[i];

                if (!row) {
                    continue;
                }

                delete that.rowById[row.id];

                row.unbound = false;

                let requestFocusUpdate = false;

                if (that._selection.focusedCell && that._selection.focusedCell.row.id === row.id) {
                    requestFocusUpdate = true;
                }

                if (that._nearRowsAdded && that._nearRowsAdded.indexOf(row) >= 0) {
                    that._nearRowsAdded.splice(that._nearRowsAdded.indexOf(row), 1);
                    that._add(0, row.data);

                    if (requestFocusUpdate) {
                        that._selection.focusedCell.row = that.rows[0];
                    }
                }
                else if (that._farRowsAdded && that._farRowsAdded.indexOf(row) >= 0) {
                    that._farRowsAdded.splice(that._farRowsAdded.indexOf(row), 1);
                    that._add(row.data);

                    if (requestFocusUpdate) {
                        that._selection.focusedCell.row = that.rows[that.rows.length - 1];
                    }
                }
            }

            that._unboundRows.splice(0, length);

            that.endUpdate();
        }
    }

    _endCellEdit(editCell) {
        const that = this;
        const cell = editCell || that.editing.editCell;

        if (!cell || (cell && !cell.isEditing)) {
            return null;
        }

        const value = that._getEditorValue(cell);

        if (value === 'invalid value') {
            cell.setAttribute('error', '');

            return false;
        }

        const commitEditChanges = function () {
            const id = that._getEditorId(cell);
            const editor = that._cellEditors[id];

            editor.detach();

            cell.row.element.removeAttribute('edit');
            cell.element.removeAttribute('editor');
            cell.element.removeAttribute('error');
            cell.isEditing = false;
            cell.element.content.innerHTML = '';

            const refresh = function () {
                if (!that.editing.editRow) {
                    that._recycle(false);
                }
            }

            const areEqual = function (value, cellValue) {
                if (cell.column.dataType === 'date') {
                    return value.valueOf() === cellValue.valueOf();
                }

                return value === cellValue;
            }

            const modifiedValue = that._cellsUpdatedValues ? that._cellsUpdatedValues[cell.row.id + '_' + cell.column.dataField] : undefined;
            const cellValue = modifiedValue !== undefined ? modifiedValue : cell.value;

            if (!areEqual(value, cellValue)) {
                const resetEditing = function () {
                    that.editing.editCell = null;

                    if (!that.editing.editRow) {
                        that.editing.isEditing = false;
                    }
                }

                if (that.editing.batch === true || (that.editing.batch && that.editing.batch.indexOf('update') >= 0)) {
                    resetEditing();
                    that._batchUpdateCell(cell.row, cell.column, value, cell.value);
                    refresh();
                }
                else {
                    const updateCellValue = function () {
                        resetEditing();
                        cell._updating = true;
                        cell.value = value;
                        cell._updating = false;
                        refresh();
                    }

                    updateCellValue();
                }
            }
            else {
                that.editing.editCell = null;

                if (!that.editing.editRow) {
                    that.editing.isEditing = false;
                    refresh();
                }
            }

            if (that.editing.commandColumn.visible && !that.editing.commandColumn.width && that.editing.mode === 'cell') {
                that.refresh();
            }

            that.focus();

            return true;
        }


        if (that.onCellUpdate) {
            that.beginUpdate();
            that.appearance.displayLoadingIndicator = true;
            that._setLoadingIndicatorVisibility();

            const overlay = that._createOverlay();
            that.$.root.appendChild(overlay);

            that.onCellUpdate(cell, that.oldValue, value, function (confirm) {
                if (confirm) {
                    commitEditChanges();
                }
                else {
                    that.cancelEdit();
                }

                that.appearance.displayLoadingIndicator = false;
                that._setLoadingIndicatorVisibility();

                overlay.parentNode.removeChild(overlay);

                that.endUpdate();
            });
        }
        else {
            commitEditChanges();
        }
    }

    _endRowEdit() {
        const that = this;

        const row = that.editing.editRow;

        if (!row) {
            return false;
        }

        let canEndEdit = true;
        const cells = row.cells;

        let oldValues = {};
        let values = {};

        for (let i = 0; i < cells.length; i++) {
            const cell = cells[i];
            const value = that._getEditorValue(cell);

            oldValues[cell.column.dataField] = cell.value;
            values[cell.column.dataField] = value;

            if (value === 'invalid value') {
                cell.setAttribute('error', '');
                canEndEdit = false;
            }
        }

        if (canEndEdit) {
            const commitEditChanges = function () {
                for (let i = 0; i < cells.length; i++) {
                    const cell = cells[i];

                    that._endCellEdit(cell);
                }

                that.editing.isEditing = false;
                that.editing.editRow = null;

                if (that.editing.commandColumn.visible && !that.editing.commandColumn.width) {
                    that.refresh();
                }
                else {
                    that._recycle(false);
                }
            }

            if (that.onRowUpdate) {
                that.beginUpdate();
                that.appearance.displayLoadingIndicator = true;
                that._setLoadingIndicatorVisibility();

                const overlay = that._createOverlay();
                that.$.root.appendChild(overlay);

                that.onRowUpdate(row, oldValues, values, function (confirm) {
                    if (confirm) {
                        commitEditChanges();
                    }
                    else {
                        that.cancelEdit();
                    }

                    that.appearance.displayLoadingIndicator = false;
                    that._setLoadingIndicatorVisibility();

                    overlay.parentNode.removeChild(overlay);

                    that.endUpdate();
                });
            }
            else {
                commitEditChanges();
            }


            return true;
        }

        that.focus();

        return false;
    }

    _batchDeleteRow(row) {
        const that = this;

        if (!that._rowsDeleted) {
            that._rowsDeleted = [];
        }

        that._rowsDeleted.push(row);
        that._recycle(false);
    }

    _batchAddRow(row, index) {
        const that = this;

        if (!that._rowsAdded) {
            that._rowsAdded = [];
        }

        that._rowsAdded.push(row.id);
        that.rowById[row.id] = row;

        row.index = that.rows.length + (that._rowsAdded ? that._rowsAdded.length : 0);

        if (index === 0) {
            that._nearRowsAdded.splice(0, 0, row);
        }
        else {
            that._farRowsAdded.push(row);
        }

        const fullRefresh = that.isInitialized && that._rowElements && that._rowElements.length < that.rows.length + that._rowsAdded.length;

        if (fullRefresh) {
            that._initializeRowElements();
        }

        that.refresh();
    }

    _batchUpdateCell(row, column, value, originalValue) {
        const that = this;

        if (!that._cellsUpdatedValues) {
            that._cellsUpdatedValues = [];
        }


        const areEqual = function (value, cellValue) {
            if (column.dataType === 'date') {
                return value.valueOf() === cellValue.valueOf();
            }

            return value === cellValue;
        }

        if (areEqual(value, originalValue)) {
            delete that._cellsUpdatedValues[row.id + '_' + column.dataField];
        }
        else {
            that._cellsUpdatedValues[row.id + '_' + column.dataField] = value;
        }

        that._cellsUpdatedValues.length++;
    }

    _saveBatchEdit() {
        const that = this;

        for (let key in that._cellsUpdatedValues) {
            const value = that._cellsUpdatedValues[key];
            const rowId = key.substring(0, key.indexOf('_'));
            const columnDataField = key.substring(key.indexOf('_') + 1);

            const row = that.rowById[rowId];
            const cell = row.getCell(columnDataField)

            cell._updating = true;
            cell.value = value;
            cell._updating = false;
        }

        const stopUpdates = (that._rowsDeleted && that._rowsDeleted.length > 0) || (that._rowsAdded && that._rowsAdded.length > 0);

        if (stopUpdates) {
            that.beginUpdate();
        }

        if (that._rowsAdded && that._rowsAdded.length > 0) {
            for (let i in that._rowsAdded) {
                const id = that._rowsAdded[i];
                const row = that.rowById[id];

                if (!row) {
                    continue;
                }

                if (that._nearRowsAdded.indexOf(row) >= 0) {
                    that.rows.splice(0, 0, row);
                }
                else if (that._farRowsAdded.indexOf(row) >= 0) {
                    that.rows.push(row);
                }
            }
        }

        if (that._rowsDeleted && that._rowsDeleted.length > 0) {
            for (let i = 0; i < that._rowsDeleted.length; i++) {
                const row = that._rowsDeleted[i];

                const index = that.rows.indexOf(row);

                if (index < 0) {
                    continue;
                }

                that.rows.splice(index, 1);
            }
        }

        if (stopUpdates) {
            that.endUpdate();
        }

        that._clearBatchEdit(false);
    }

    _clearBatchEdit(/*revertNewRows*/) {
        const that = this;


        let requiresRefresh = false;

        if (that._rowsAdded && that._rowsAdded.length > 0) {
            requiresRefresh = true;
        }

        that._cellsUpdatedValues = [];
        that._rowsAdded = [];
        that._rowsDeleted = [];
        that._nearRowsAdded = [];
        that._farRowsAdded = [];

        if (requiresRefresh) {
            that.refresh();
        }
        else {
            that._recycle(false);
        }
    }

    _getEditorId(cell) {
        if (cell.editor !== cell.column.editor) {
            return cell.editor.template + '_' + cell.column.dataField + '_' + cell.row.id;
        }

        return cell.editor.template + '_' + cell.column.dataField;
    }

    _applyCommand(command, params) {
        const that = this;

        if (!params) {
            params = [];
        }

        const onApplyCommand = function () {
            if (typeof command === 'function') {
                command.apply(that, params);
            }
            else if (that[command]) {
                that[command].apply(that, params);
            }
            else if (Smart[command]) {
                Smart[command].apply(that, params);
            }
            else if (window[command]) {
                window[command].apply(that, params);
            }
        }

        if (that.onCommand) {
            if (!params) {
                params = [];
            }

            if (!params[1]) {
                params[1] = null;
            }

            const args = { name: command, command: onApplyCommand, details: params[0], event: params[1], handled: false };

            setTimeout(() => {
                that.onCommand.apply(that, [args]);

                if (args.handled) {
                    return;
                }

                onApplyCommand();
            }, 200);
        }
        else {
            onApplyCommand();
        }
    }

    _getCommandColumnCommandsTemplate() {
        const that = this;

        const dataSource = that.editing.commandColumn.dataSource;

        const showLabel = that.editing.commandColumn.displayMode !== 'icon';
        const showIcon = that.editing.commandColumn.displayMode !== 'label';

        let template = '';

        for (let item in dataSource) {
            const properties = dataSource[item];

            let commandColumnItem = '<div';
            let isCommandSet = false;

            if (item === 'commandColumnMenu') {
                continue;
            }

            if (!isCommandSet) {
                commandColumnItem += ' item="' + item + '" command="' + properties.command + '"' + ' class="smart-grid-command-item">';
                isCommandSet = true;
            }

            const label = properties.label === '{{messages}}' ? that.localize(item) : properties.label;

            if (showIcon && showLabel) {
                commandColumnItem += '<span class="smart-grid-icon ' + properties.icon + '"></span>';
                commandColumnItem += '<span class="smart-grid-label">' + label + '</span>';
            }
            else if (showIcon && !showLabel) {
                commandColumnItem += '<span class="smart-grid-icon ' + properties.icon + '"></span>';
            }
            else if (showLabel && !showIcon) {
                commandColumnItem += '<span class="smart-grid-label">' + label + '</span>';
            }

            commandColumnItem += '</div>';

            template += commandColumnItem;
        }

        return template;
    }

    _updateCommandColumnCommandsVisibility(element, row) {
        const that = this;
        const commands = element.children;
        //const commandItems = [];
        const dataSource = that.editing.commandColumn.dataSource;

        for (let i = 0; i < commands.length; i++) {
            const command = commands[i];
            const item = command.getAttribute('item');
            const visible = dataSource[item].visible;

            if (visible === true) {
                command.classList.remove('smart-hidden');
            }
            else if (visible === false) {
                command.classList.add('smart-hidden');
            }
            else if (visible === 'auto') {
                if (!that.editing.dialog.enabled && (that.editing.editRow === row || (that.editing.editCell && that.editing.editCell.row === row))) {
                    if (item === 'commandColumnEdit') {
                        command.classList.add('smart-hidden');
                    }
                    else if (item === 'commandColumnUpdate' || item === 'commandColumnCancel') {
                        commands[i].classList.remove('smart-hidden');
                    }
                }
                else {
                    if (item === 'commandColumnEdit') {
                        command.classList.remove('smart-hidden');
                    }
                    else if (item === 'commandColumnUpdate' || item === 'commandColumnCancel') {
                        commands[i].classList.add('smart-hidden');
                    }
                }
            }
        }
    }

    _handleEditKeyDown(event) {
        const that = this;
        const key = event.key;
        const dataSource = that.editing.commandKeys;

        if (that.editing.dialog.enabled) {
            return;
        }

        for (let item in dataSource) {
            const properties = dataSource[item];
            const keys = properties.key.replace(/ /ig, '').split('|');

            if (key === 'Tab' && that.editing.editRow) {
                continue;
            }

            if (keys.indexOf(key) >= 0) {
                that._applyCommand(properties.command);
                break;
            }
        }
    }

    _getCustomCellEditor(cell) {
        const that = this;

        cell.editor.selector = cell.editor.template;
        cell.editor.template = 'custom';

        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('div');


            that._applyCellEditorUserSettings(element, cell);

            element.classList.add('smart-grid-cell-editor');

            const command = function (event) {
                //let key = event.key;

                if (event.type === 'keydown') {
                    that._handleEditKeyDown(event);

                    return;
                }
            };

            const focus = function () {
                const element = cell.editor.instance.element.firstElementChild;

                if (cell.editor.focus) {
                    setTimeout(function () {
                        cell.editor.focus.apply(cell.editor.instance.element, []);
                    }, 50);
                }
                else {
                    setTimeout(function () {
                        element.focus();
                    }, 50);
                }
            }

            const blur = function (event) {
                const element = cell.editor.instance.element.firstElementChild;

                if (cell.editor.blur) {
                    cell.editor.blur.apply(cell.editor.instance.element, [event]);
                }
                else {
                    element.blur();
                }
            }

            const setValue = function (value) {
                const element = cell.editor.instance.element.firstElementChild;

                if (cell.editor.setValue) {
                    cell.editor.setValue.apply(cell.editor.instance.element, [value]);
                }
                else {
                    if (element.innerHTML.indexOf('{{') >= 0) {
                        const html = element.innerHTML.replace(/{{value}}/ig, value).replace(/{{id}}/ig, cell.row.id);

                        element.innerHTML = html;
                    }

                    element.value = value;

                    if (value instanceof Date) {
                        element.value = value.toISOString().split('T')[0];
                    }

                    cell.editor.instance.element.value = element.value;
                }
            }

            const getValue = function () {
                const element = cell.editor.instance.element.firstElementChild;

                if (cell.editor.getValue) {
                    return cell.editor.getValue.apply(cell.editor.instance.element, []);
                }

                const value = element.value;

                return value || '';
            }

            const detach = function () {

                element.removeEventListener('keydown', command);

                if (cell.editor.detach) {
                    cell.editor.detach.apply(element, []);
                }
            }

            const attach = function () {
                element.addEventListener('keydown', command);

                if (cell.editor.attach) {
                    cell.editor.attach.apply(element, []);
                }
            }

            let template = null;

            if (cell.editor.selector.startsWith('#') || cell.editor.selector.startsWith('.')) {
                template = document.querySelector(cell.editor.selector);
            }

            if (template) {
                element.appendChild(template.content.cloneNode(true).firstElementChild);
            }
            else {
                const htmlToElement = function (html) {
                    const template = document.createElement('template');

                    html = html.trim(); // Never return a text node of whitespace as the result
                    template.innerHTML = html;
                    return template.content.firstChild;
                }

                const templateElement = htmlToElement(cell.editor.selector);

                if (templateElement) {
                    element.appendChild(templateElement);
                }
            }

            that._cellEditors[id] = { element: element, focus: focus, blur: blur, getValue: getValue, setValue: setValue, attach: attach, detach: detach };
        }

        return that._cellEditors[id];
    }

    _getTextAreaCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        const element = document.createElement('div');
        const textarea = document.createElement('textarea');
        const expander = document.createElement('div');

        that._applyCellEditorUserSettings(element, cell);

        textarea.style.direction = '';
        if (that.rightToLeft) {
            textarea.style.direction = 'rtl';
        }

        textarea.classList.add('smart-input');
        element.classList.add('smart-grid-cell-editor');
        element.classList.add('smart-grid-text-area-cell-editor');
        expander.classList.add('nav');

        expander.classList.add('smart-icon-resize-full', 'smart-grid-icon');

        const command = function (event) {
            let key = event.key;

            if (event.type === 'keydown') {
                that._handleEditKeyDown(event);

                if (event.shiftKey && key === ' ') {
                    expander.click();
                    event.preventDefault();
                }
                return;
            }
        };

        expander.onclick = function () {
            const textAreaEditorDialog = document.createElement('div');
            const closeButton = document.createElement('span');
            const popupTextArea = document.createElement('textarea');
            const element = cell.editor.instance.element;
            const textAreaContainer = document.createElement('div');
            const scrollBar = document.createElement('smart-scroll-bar');

            scrollBar.orientation = 'vertical';

            textAreaEditorDialog.setAttribute('theme', that.theme);
            textAreaContainer.appendChild(popupTextArea);

            textAreaContainer.classList.add('smart-grid-text-area-container');
            textAreaContainer.appendChild(scrollBar);

            popupTextArea.value = textarea.value;
            popupTextArea.classList.add('smart-input');

            expander.textAreaEditorDialog = textAreaEditorDialog;
            expander.popupTextArea = popupTextArea;

            closeButton.classList.add('close-button');
            closeButton.classList.add('smart-grid-icon');
            closeButton.classList.add('smart-icon-cancel-circled');

            //let tempValueLength = 0;

            const updateScrollBar = function () {
                scrollBar.value = popupTextArea.scrollTop;
                scrollBar.max = popupTextArea.scrollHeight - popupTextArea.offsetHeight;

                scrollBar.onChange = null;

                if (popupTextArea.offsetHeight >= popupTextArea.scrollHeight) {
                    scrollBar.classList.add('smart-hidden');
                }
                else {
                    scrollBar.classList.remove('smart-hidden');
                }

                scrollBar.onChange = function () {
                    popupTextArea.scrollTop = scrollBar.value;
                }
            }

            popupTextArea.onscroll = function (/*event*/) {
                updateScrollBar();
            }

            popupTextArea.onkeydown = function (event) {
                if (event.key === 'Escape') {
                    textAreaEditorDialog.parentNode.removeChild(textAreaEditorDialog);
                }

                if (event.key === 'Enter' && event.shiftKey) {
                    closeButton.click();
                }

                //tempValueLength = popupTextArea.value.length;
            }

            closeButton.onclick = function () {
                expander.textAreaEditorDialog.parentNode.removeChild(expander.textAreaEditorDialog);
                setTimeout(function () {
                    textarea.value = popupTextArea.value;
                    textarea.select();
                }, 50);
            }

            textAreaEditorDialog.classList.add('smart-grid-text-area-dialog');

            textAreaEditorDialog.appendChild(textAreaContainer);
            textAreaEditorDialog.appendChild(closeButton);

            document.body.appendChild(textAreaEditorDialog);

            setTimeout(function () {
                popupTextArea.select();
                updateScrollBar();
            }, 50);

            updateScrollBar();
            textAreaEditorDialog.style.top = that._offsetTop(element) + 'px';
            textAreaEditorDialog.style.left = that._offsetLeft(element) + 'px';
            textAreaEditorDialog.style.width = element.offsetWidth + 'px';
        }

        element.appendChild(textarea);
        element.appendChild(expander);

        const getValue = function () {
            const value = textarea.value;

            if (expander.textAreaEditorDialog && expander.textAreaEditorDialog.parentNode) {
                textarea.value = expander.popupTextArea.value;

                return textarea.value;
            }

            return value;
        }

        const setValue = function (value) {
            textarea.value = value;
        }

        const focus = function () {
            setTimeout(function () {
                textarea.select();
            }, 50);
        }

        const blur = function () {

        }

        const attach = function () {
            textarea.addEventListener('keydown', command);
        }

        const detach = function () {
            textarea.removeEventListener('keydown', command);

            if (expander.textAreaEditorDialog && expander.textAreaEditorDialog.parentNode) {
                textarea.value = expander.popupTextArea.value;
                expander.textAreaEditorDialog.parentNode.removeChild(expander.textAreaEditorDialog);
            }
        }

        that._cellEditors[id] = { element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach };


        return that._cellEditors[id];
    }

    _getInputCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('input');

            that._applyCellEditorUserSettings(element, cell);

            element.classList.add('smart-input');
            element.classList.add('smart-grid-cell-editor');
            element.classList.add('smart-grid-input-cell-editor');

            element.style.direction = '';
            if (that.rightToLeft) {
                element.style.direction = 'rtl';
            }

            const command = function (event) {
                //let key = event.key;

                if (event.type === 'keydown') {
                    if (cell.column.dataType === 'number' || cell.column.dataType === 'int' || cell.column.dataType === 'float') {
                        if (!that.editing.editColumn && !event.key.match(/[0-9]/) && event.key !== '-' && event.key.length === 1) {
                            event.preventDefault();
                            event.stopPropagation();
                            return;
                        }
                    }

                    that._handleEditKeyDown(event);

                    return;
                }
            };

            const focus = function () {
                setTimeout(function () {
                    element.select();
                }, 50);
            }

            const blur = function () {

            }

            const setValue = function (value) {
                if (cell.column.rowHeaderColumn && !value) {
                    element.value = cell.editor.row.visibleIndex + 1;

                    return;
                }

                if (cell.column.dataType === 'number' || cell.column.dataType === 'int' || cell.column.dataType === 'float') {
                    if (value === '') {
                        return;
                    }

                    if (value && !value.toString().match(/[0-9]/) && value !== '-') {
                        return;
                    }
                }

                element.value = value;
            }

            const getValue = function () {
                return element.value;
            }

            const detach = function () {
                element.removeEventListener('keydown', command);
            }

            const attach = function () {
                element.addEventListener('keydown', command);
            }

            that._cellEditors[id] = { element: element, focus: focus, blur: blur, getValue: getValue, setValue: setValue, attach: attach, detach: detach };
        }

        return that._cellEditors[id];
    }

    _applyCellEditorUserSettings(editor, cell) {
        //const that = this;

        for (let property in cell.editor) {
            if (property === 'template') {
                continue;
            }

            if (property === 'list') {
                editor.setAttribute(property, cell.editor[property]);
                continue;
            }

            editor[property] = cell.editor[property];
        }
    }

    _getAutoCompleteCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('smart-input');

            that._applyCellEditorUserSettings(element, cell);

            if (element.readonly) {
                element.dropDownButtonPosition = 'right';
            }

            const command = function (event) {
                //let key = event.key;

                if (element.opened) {
                    return;
                }

                if (event.type === 'keydown') {
                    that._handleEditKeyDown(event);
                    return;
                }
            };

            element.rightToLeft = that.rightToLeft;
            element.classList.add('smart-grid-cell-editor');
            element.classList.add('smart-grid-auto-complete-cell-editor');

            const focus = function () {
                setTimeout(() => {
                    if (element && element.select) {
                        element.select();
                    }
                }, 50);
            }

            const setValue = function (value) {
                element.value = value;
            }

            const getValue = function () {
                return element.value;
            }

            const detach = function () {
                if (element && element.close) {
                    element.value = '';
                    element.close();
                    element.removeEventListener('keydown', command);
                }
            }

            const blur = function () {

            }

            const attach = function () {
                element.addEventListener('keydown', command);
            }

            that._cellEditors[id] = { element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach };
        }


        const rows = that.getVisibleRows();
        const items = [];

        for (let i = 0; i < rows.length; i++) {
            let item = that.dataSource[rows[i].index];

            if (item) {
                item = item[cell.column.dataField];

                if (items.indexOf(item) === -1) {
                    items.push(item);
                }
            }
        }

        that._cellEditors[id].element.dataSource = items;

        return that._cellEditors[id];
    }

    _getDateTimePickerCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('smart-date-time-picker');

            element.calendarButton = true;
            element.dropDownAppendTo = 'body';
            element.autoClose = true;
            element.dropDownDisplayMode = 'calendar';
            element.rightToLeft = that.rightToLeft;

            that._applyCellEditorUserSettings(element, cell);

            const command = function (event) {
                //let key = event.key;

                if (element.opened) {
                    return;
                }

                if (event.type === 'keydown') {
                    that._handleEditKeyDown(event);
                    return;
                }
            };


            element.classList.add('smart-grid-cell-editor');
            element.classList.add('smart-grid-date-time-picker-cell-editor');

            const focus = function () {
                setTimeout(() => {
                    element.select();
                }, 50);
            }

            const setValue = function (value) {
                element.value = value;
            }

            const getValue = function () {
                return element.value;
            }

            const detach = function () {
                element.value = '';
                element.close();
                element.removeEventListener('keydown', command);
            }

            const blur = function (event) {
                const dropDownId = element.getAttribute('aria-controls');

                if (dropDownId && element.opened) {
                    const boundingRect = that.getBoundingRect(document.getElementById(dropDownId));

                    if (!(event.pageX < boundingRect.left || event.pageX > boundingRect.right || event.pageY < boundingRect.top || event.pageY > boundingRect.bottom)) {
                        event.preventDefault();
                    }
                }
            }

            //const cancel = function () {
            //    return false;
            //}

            const attach = function () {
                element.addEventListener('keydown', command);
            }

            that._cellEditors[id] = { element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach };
        }

        return that._cellEditors[id];
    }

    _getNumberInputCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('div');
            const numberInput = document.createElement('input');
            const spinner = document.createElement('div');
            const spinnerUp = document.createElement('div');
            const spinnerDown = document.createElement('div');

            that._applyCellEditorUserSettings(element, cell);

            spinnerUp.tabIndex = spinnerDown.tabIndex = -1;
            numberInput.classList.add('smart-input');
            element.classList.add('smart-grid-cell-editor');
            element.classList.add('smart-grid-number-input-cell-editor');
            spinner.classList.add('nav');
            spinnerUp.classList.add('up');
            spinnerDown.classList.add('down');

            const command = function (event) {
                if (event.type === 'keydown') {
                    that._handleEditKeyDown(event);
                    return;
                }
            };

            numberInput.type = 'number';

            spinner.appendChild(spinnerUp);
            spinner.appendChild(spinnerDown);
            element.appendChild(numberInput);
            element.appendChild(spinner);


            const getValue = function () {
                const value = parseFloat(numberInput.value);

                if (isNaN(value) || value === Infinity || value === -Infinity) {
                    return 0;
                }

                return value;
            }

            const setValue = function (value) {
                numberInput.value = value;
            }

            const focus = function () {
                setTimeout(function () {
                    numberInput.select();
                }, 50);
            }

            const blur = function () {

            }

            const attach = function () {
                numberInput.addEventListener('keydown', command);
                spinnerUp.onkeydown = command;
                spinnerDown.onkeydown = command;

                spinnerUp.onclick = function () {
                    const oldValue = parseFloat(numberInput.value);

                    if (isNaN(oldValue)) {
                        return;
                    }

                    if (oldValue < numberInput.max || numberInput.max === '') {
                        numberInput.value = oldValue + 1;
                    }
                };

                spinnerDown.onclick = function () {
                    const oldValue = parseFloat(numberInput.value);

                    if (isNaN(oldValue)) {
                        return;
                    }

                    if (oldValue > numberInput.min || numberInput.min === '') {
                        numberInput.value = oldValue - 1;
                    }
                };
            }

            const detach = function () {
                numberInput.removeEventListener('keydown', command);

                spinnerUp.onclick = spinnerDown.onclick = null;
                spinnerUp.onkeydown = spinnerDown.onkeydown = null;
            }

            that._cellEditors[id] = { element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach };
        }

        return that._cellEditors[id];
    }

    _getCheckBoxCellEditor(cell) {
        const that = this;
        const id = that._getEditorId(cell);

        if (!that._cellEditors[id]) {
            const element = document.createElement('div');

            element.classList.add('smart-input');
            element.classList.add('smart-grid-cell-editor');
            element.classList.add('smart-grid-check-box-cell-editor');
            element.tabIndex = 0;

            const command = function (/*event*/) {
                if (element.value !== true && element.value !== false && element.value !== null) {
                    element.value = false;
                }

                if (element.value === null) {
                    element.value = false;
                }
                else {
                    element.value = !element.value;
                }

                if (false === element.value) {
                    element.removeAttribute('checked');
                }
                else {
                    element.setAttribute('checked', element.value ? '' : 'indeterminate');
                }
            };

            const keyDownHandler = function (event) {
                if (event.key === ' ') {
                    command();
                    return;
                }

                that._handleEditKeyDown(event);
            }

            const setValue = function (value) {
                element.value = value;

                if (false === element.value) {
                    element.removeAttribute('checked');
                }
                else {
                    element.setAttribute('checked', element.value ? '' : 'indeterminate');
                }
            }

            const focus = function () {
                element.focus();

                setTimeout(function () {
                    element.focus();
                }, 25);
            }

            const getValue = function () {
                return element.value;
            }

            const detach = function () {
                element.value = false;
                element.removeEventListener('click', command);
                element.removeEventListener('keydown', keyDownHandler);
            }

            const blur = function () {

            }

            const attach = function () {
                element.addEventListener('keydown', keyDownHandler);
                element.addEventListener('click', command);
            }

            that._cellEditors[id] = {
                getValue: getValue,
                setValue: setValue,
                focus: focus,
                blur: blur,
                element: element,
                detach: detach,
                attach: attach
            };
        }

        return that._cellEditors[id];
    }

    _getEditorValue(cell) {
        const that = this;

        const id = that._getEditorId(cell);

        if (!that._cellEditors) {
            return undefined;
        }

        const editor = that._cellEditors[id];

        if (!editor) {
            return undefined;
        }

        const parseValue = function (value) {
            switch (cell.column.dataType) {
                case 'float':
                case 'int':
                case 'number':
                    value = cell.column.dataType === 'int' ? parseInt(value) : parseFloat(value);

                    if (isNaN(value)) {
                        value = 0;
                    }
                    break;
                case 'bool':
                case 'boolean':
                    if (value === 'true' || value === '1') {
                        value = true;
                    }

                    if (value === 'false' || value === '0') {
                        value = false;
                    }
                    break;
                case 'date':
                    value = new Smart.Utilities.DateTime(value);

                    value = value.toDate();
                    break;
                case 'dateTime':
                    value = new Smart.Utilities.DateTime(value);

                    break;
            }

            return value;
        }

        let value = null;

        switch (cell.editor.template) {
            case 'input':
            case 'autoComplete':
            case 'numberInput':
            case 'deteTimePicker':
            case 'checkBox': {
                try {
                    value = parseValue(editor.getValue());
                }
                catch (error) {
                    value = cell.value;
                }

                if (cell.editor.getValue) {
                    const customValue = cell.editor.getValue(cell, value);

                    if (customValue !== undefined) {
                        value = customValue;
                    }
                }

                break;
            }
            default: {
                value = parseValue(editor.getValue());
            }
        }

        let isValid = true;

        if (cell.column.validator) {
            isValid = cell.column.validator.evaluate(value);
        }

        if (isValid) {
            return value;
        }

        return 'invalid value';
    }

    _beginRowEdit(row, clickedCell/*, event*/) {
        const that = this;

        if (row === that.editing.editRow) {
            return false;
        }

        if (that.editing.editRow) {
            const canEndEdit = that.endEdit();

            if (!canEndEdit) {
                return false;
            }
        }

        const cells = row.cells;

        that.editing.editRow = row;

        if (that.editing.commandColumn.visible) {
            that.editing.isEditing = false;

            that.refresh();

            that.editing.isEditing = true;
        }

        row.isEditing = true;

        let isFirstCell = false;

        for (let i = 0; i < cells.length; i++) {
            const cell = cells[i];

            const result = that._beginCellEdit(cell);

            if (!clickedCell) {
                if (result && !isFirstCell) {
                    isFirstCell = true;

                    cell.editor.instance.focus();
                }
            }
            else if (cell === clickedCell) {
                cell.editor.instance.focus();
            }

            if (that.editing.commandColumn.visible && cell.column.commandColumn) {
                cell.render();
            }
        }

        return true;
    }

    _createOverlay() {
        const overlay = document.createElement('div');

        overlay.onpointerdown = function () {
            return false;
        }
        overlay.onmousedown = function () {
            return false;
        }
        overlay.onclick = function () {
            return;
        }

        overlay.classList.add('smart-grid-dialog-overlay');

        return overlay;
    }

    _createDialog(options) {
        const that = this;
        const dialog = document.createElement('div');

        if (!options) {
            options = that.editing.dialog;
        }

        dialog.setAttribute('animation', 'none');
        dialog.classList.add('smart-window', 'smart-grid-dialog');
        dialog.style.width = options.width === 'auto' ? options.width : options.width + 'px';
        dialog.style.height = options.height === 'auto' ? options.height : options.height + 'px';
        dialog.style.left = '';
        dialog.style.top = '';

        dialog.innerHTML =
            `<div class="smart-container">
                   <div class ="smart-content-container" smart-id="container">
                        <div id="headerSection" class="smart-header-section">
                            <div class="smart-header"></div>
                            <div class="smart-buttons-container">
                                <button class ="smart-button smart-element smart-close-button" aria-label="Close" smart-id="closeButton"></button>
                            </div>
                        </div>
                        <div class="smart-content"><div></div></div>
                        <div class ="smart-footer">
                            <div class ="smart-stack-layout right spacing">
                                <smart-button class ="smart-confirm-button item primary">Ok</smart-button>
                                <smart-button class ="smart-cancel-button item">Cancel</smart-button>
                            </div>
                        </div>
                    </div>
              </div>
            `;

        dialog.content = dialog.querySelector('.smart-content').firstChild;
        dialog.footer = dialog.querySelector('.smart-footer');
        dialog.header = dialog.querySelector('.smart-header');
        dialog.btnConfirm = dialog.querySelector('.smart-confirm-button');
        dialog.btnCancel = dialog.querySelector('.smart-cancel-button');
        dialog.btnClose = dialog.querySelector('.smart-close-button');
        const overlay = document.createElement('div');

        overlay.classList.add('smart-grid-dialog-overlay');

        overlay.onclick = function () {
            return;
        }

        dialog.overlay = overlay;

        dialog.remove = function () {
            if (dialog.parentNode) {
                dialog.parentNode.removeChild(dialog);
            }
        };

        dialog.close = function () {
            dialog.classList.remove('open');

            dialog.addEventListener('transitionend', dialog.remove);
            dialog.addEventListener('transitioncancel', dialog.remove);

            if (dialog.modal) {
                if (dialog.overlay.parentNode) {
                    dialog.overlay.parentNode.removeChild(dialog.overlay);
                }
            }

            if (dialog.onClose) {
                dialog.onClose();
            }
        }


        dialog.open = function (left, top) {
            dialog.removeEventListener('transitionend', dialog.remove);
            dialog.removeEventListener('transitioncancel', dialog.remove);

            document.body.appendChild(dialog);

            if (!left) {
                left = options.left;
            }

            if (!top) {
                top = options.top;
            }

            requestAnimationFrame(function () {
                dialog.classList.add('open');

                const positionFromString = function (position, alignment) {
                    const offset = that.offset(that);

                    if (position === 'center' && alignment === 'horizontal') {
                        position = 'middle';
                    }

                    switch (position) {
                        case 'top':
                            return offset.top;
                        case 'bottom':
                            return offset.top + that.offsetHeight - dialog.offsetHeight;
                        case 'center':
                            return offset.top + that.offsetHeight / 2 - dialog.offsetHeight / 2;
                        case 'left':
                            return offset.left;
                        case 'middle':
                            return offset.left + that.offsetWidth / 2 - dialog.offsetWidth / 2;
                        case 'right':
                            return offset.left + that.offsetWidth - dialog.offsetWidth;
                    }

                    if (alignment === 'horizontal') {
                        return parseInt(position) + offset.left;
                    }

                    if (alignment === 'vertical') {
                        return parseInt(position) + offset.top;
                    }

                    if (typeof position === 'number') {
                        return position;
                    }

                    return parseInt(position);
                }

                dialog.style.left = positionFromString(left, 'horizontal') + 'px';
                dialog.style.top = positionFromString(top, 'vertical') + 'px';
            });

            if (dialog.modal) {
                that.appendChild(dialog.overlay);
            }

            if (dialog.onOpen) {
                dialog.onOpen();
            }
        }

        return dialog;
    }

    _openAddRowDialog(row, command) {
        const that = this;

        if (!that.editing.addDialog.enabled) {
            return false;
        }

        const dialog = that._dialogAddRow || that._createDialog();
        const header = that.editing.dialog.header === '{{message}}' ? that.localize('dialogAddHeader') : that.editing.dialog.header;
        const content = dialog.content;

        dialog.header.innerHTML = header;

        row.grid = that;

        if (undefined === row.index) {
            row.index = that.rows.length;

            if (that._rowsAdded) {
                row.index += that._rowsAdded.length;
            }
        }

        const cells = row.cells;

        let layoutRow = null;
        let layoutRowIndex = 0;

        if (!that._cellEditors) {
            that._cellEditors = [];
        }

        if (!that._dialogAddRow) {
            dialog.modal = true;
            dialog.btnConfirm.innerHTML = that.localize('dialogAddButtonConfirm');
            dialog.btnCancel.innerHTML = that.localize('dialogAddButtonCancel');

            dialog.onOpen = function () {
                that.editing.dialog.visible = true;
            }

            dialog.onClose = function () {
                that.editing.dialog.visible = false;
            }

            dialog.btnCancel.onclick = function () {
                dialog.close();
            }

            dialog.btnClose.onclick = function () {
                dialog.close();
            }

            dialog.btnConfirm.onclick = function () {
                const data = {
                };

                for (let i = 0; i < cells.length; i++) {
                    const cell = cells[i];
                    const value = that._getEditorValue(cell);
                    const id = that._getEditorId(cell);
                    const editor = that._cellEditors[id];

                    data[cell.column.dataField] = value;

                    editor.detach();
                }

                const index = that._rowsAdded ? that._rowsAdded.length : 0;

                const row = new Smart.Grid.Row({ index: that.rows.length + index, grid: that, data: data });

                dialog.close();

                command(row, dialog.index === 0 ? true : false);
            }

            dialog.onkeydown = function (event) {
                const key = event.key;

                if (key === 'Enter') {
                    dialog.btnConfirm.onclick();
                }
                else if (key === 'Escape') {
                    dialog.close();
                }
            }

            content.classList.add('smart-grid-layout');

            for (let i = 0; i < that.columns.length; i++) {
                const column = that.columns[i];

                if (!column.allowEdit) {
                    continue;
                }

                if (layoutRowIndex % 2 === 0) {
                    layoutRow = document.createElement('div');
                    layoutRow.classList.add('row');
                    content.appendChild(layoutRow);
                }

                const col = document.createElement('div');

                col.classList.add('col-sm-6');

                const stack = document.createElement('div');

                stack.classList.add('column');

                const label = document.createElement('label');

                label.innerHTML = that.columns[i].label;

                const fieldEditor = document.createElement('div');

                fieldEditor.classList.add('smart-grid-dialog-editor')
                fieldEditor.setAttribute('editor', column.dataField);
                fieldEditor.setAttribute('template', column.editor.template);

                col.appendChild(stack);
                layoutRow.appendChild(col);
                stack.appendChild(label);
                stack.appendChild(fieldEditor);
                layoutRowIndex++;
            }
        }

        dialog.open();
        dialog.index = row.index;

        for (let i = 0; i < cells.length; i++) {
            const cell = cells[i];
            const column = cell.column;
            const dataField = column.dataField;
            const fieldEditor = dialog.querySelector('[editor=' + dataField + ']');

            fieldEditor.innerHTML = '';

            let cellValue = '';

            if (cell.value !== undefined) {
                cellValue = cell.value;
            }
            else {
                if (column.dataType === 'int64' || column.dataType === 'number' || column.dataType === 'int' || column.dataType === 'float') {
                    cellValue = 0;
                }

                if (column.dataType === 'date') {
                    cellValue = new Date();
                }

                if (column.dataType === 'bool' || column.dataType === 'boolean') {
                    cellValue = false;
                }
            }
            let editor = null;

            switch (cell.editor.template) {
                default:
                case 'custom': {
                    editor = that._getCustomCellEditor(cell);

                    break;
                }
                case 'checkBox': {
                    editor = that._getCheckBoxCellEditor(cell);

                    break;
                }
                case 'autoComplete': {
                    editor = that._getAutoCompleteCellEditor(cell);

                    break;
                }
                case 'dateTimePicker':
                    editor = that._getDateTimePickerCellEditor(cell);

                    break;
                case 'textArea':
                case 'textarea':
                    {
                        editor = that._getTextAreaCellEditor(cell);

                        break;
                    }
                case 'numberInput':
                case 'input':
                    {
                        editor = cell.editor.template === 'numberInput' ? that._getNumberInputCellEditor(cell) : that._getInputCellEditor(cell);

                        break;
                    }
            }

            editor.attach();

            cell.editor.instance = editor;
            editor.setValue(cellValue);

            if (i === 0) {
                editor.focus();
            }
            if (!cell.editor.isInitialized) {
                cell.editor.isInitialized = true;

                if (cell.editor.onInit) {
                    cell.editor.onInit(cell.row.index, cell.column.dataField, cell.editor.instance.element);
                }
            }

            if (cell.editor.onRender) {
                cell.editor.onRender(cell.row.index, cell.column.dataField, cell.editor.instance.element);
            }

            fieldEditor.appendChild(editor.element);
        }

        that._dialogAddRow = dialog;
    }

    _openEditDialog(cell, editor) {
        const that = this;

        if (!that.editing.dialog.enabled) {
            return false;
        }

        const dialog = that._dialogEdit || that._createDialog();
        const header = that.editing.dialog.header === '{{message}}' ? that.localize('dialogEditHeader', { value: that.editing.editRow ? (cell.row.visibleIndex + 1) : cell.column.label }) : that.editing.dialog.header;
        const content = dialog.content;

        dialog.header.innerHTML = header;

        let row = null;
        let layoutRowIndex = 0;

        if (!that._dialogEdit) {
            dialog.modal = true;
            dialog.btnConfirm.innerHTML = that.localize('dialogEditButtonConfirm');
            dialog.btnCancel.innerHTML = that.localize('dialogEditButtonCancel');

            dialog.onOpen = function () {
                that.editing.dialog.visible = true;
            }

            dialog.onClose = function () {
                that.editing.dialog.visible = false;
            }

            dialog.btnCancel.onclick = function () {
                that.cancelEdit();
            }

            dialog.btnClose.onclick = function () {
                that.cancelEdit();
            }

            dialog.btnConfirm.onclick = function () {
                that.endEdit();
            }

            dialog.onkeydown = function (event) {
                const key = event.key;
                const dataSource = that.editing.commandKeys;

                for (let item in dataSource) {
                    const properties = dataSource[item];

                    if (key === properties.key) {
                        that._applyCommand(properties.command);
                        break;
                    }
                }
            }

            if (that.editing.editRow) {
                content.classList.add('smart-grid-layout');

                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    if (!column.allowEdit) {
                        continue;
                    }

                    if (layoutRowIndex % 2 === 0) {
                        row = document.createElement('div');
                        row.classList.add('row');
                        content.appendChild(row);
                    }

                    const col = document.createElement('div');

                    col.classList.add('col-sm-6');

                    const stack = document.createElement('div');

                    stack.classList.add('column');

                    const label = document.createElement('label');

                    label.innerHTML = that.columns[i].label;

                    const fieldEditor = document.createElement('div');

                    fieldEditor.classList.add('smart-grid-dialog-editor')
                    fieldEditor.setAttribute('editor', column.dataField);
                    fieldEditor.setAttribute('template', column.editor.template);

                    col.appendChild(stack);
                    row.appendChild(col);
                    stack.appendChild(label);
                    stack.appendChild(fieldEditor);
                    layoutRowIndex++;
                }
            }
            else {
                const column = cell.column;

                const fieldEditor = document.createElement('div');

                fieldEditor.classList.add('smart-grid-dialog-editor')
                fieldEditor.setAttribute('editor', '');
                fieldEditor.setAttribute('template', column.editor.template);

                content.appendChild(fieldEditor);
            }
        }

        dialog.open();

        if (that.editing.editRow) {
            const fieldEditor = dialog.querySelector('[editor=' + cell.column.dataField + ']');

            fieldEditor.innerHTML = '';
            fieldEditor.appendChild(editor.element);
        }
        else {
            const column = cell.column;
            const fieldEditor = dialog.querySelector('[editor]');

            fieldEditor.innerHTML = '';

            fieldEditor.setAttribute('template', column.editor.template);
            fieldEditor.appendChild(editor.element);
        }


        that._dialogEdit = dialog;
    }

    _openDeleteRowDialog(row, command) {
        const that = this;

        if (!that.editing.deleteDialog.enabled) {
            return false;
        }

        const dialog = that._dialogDelete || that._createDialog();
        const header = that.editing.dialog.header === '{{message}}' ? that.localize('dialogDeleteHeader', { value: row.visibleIndex + 1 }) : that.editing.dialog.header;
        //const content = dialog.content;

        dialog.header.innerHTML = header;
        dialog.content.innerHTML = that.localize('dialogDeleteContent');
        dialog.row = row;

        if (!that._dialogDelete) {
            dialog.modal = true;
            dialog.btnConfirm.innerHTML = that.localize('dialogDeleteButtonConfirm');
            dialog.btnCancel.innerHTML = that.localize('dialogDeleteButtonCancel');

            dialog.onOpen = function () {
                that.editing.dialog.visible = true;
            }

            dialog.onClose = function () {
                that.editing.dialog.visible = false;
            }

            dialog.btnCancel.onclick = function () {
                dialog.close();
            }

            dialog.btnClose.onclick = function () {
                dialog.close();
            }

            dialog.btnConfirm.onclick = function () {
                command(dialog.row);
                dialog.close();
            }

            dialog.onkeydown = function (event) {
                if (event.key === 'Escape') {
                    dialog.close();
                }
            }
            that._dialogDelete = dialog;
        }

        dialog.open();

        setTimeout(function () {
            dialog.btnConfirm.focus();
        }, 100);
    }

    _beginCellEdit(cell, event) {
        const that = this;

        if (cell.isEditing) {
            return false;
        }

        let allowRowHeaderEdit = false;

        if (cell.column.autoGenerated && cell.column.rowHeaderColumn && that.editing.allowRowHeaderEdit) {
            if (new Date() - that._clickTime < that.behavior.doubleClickTimingDelay) {
                if (that._clickedCell === cell.element) {
                    allowRowHeaderEdit = true;
                }
            }
        }

        if (!(cell.column.allowEdit && !cell.column.autoGenerated && !cell.readonly) && !allowRowHeaderEdit) {
            return false;
        }

        if (that.editing.editCell && !that.editing.editRow) {
            const successfulEdit = that._endCellEdit();

            if (false === successfulEdit) {
                return false;
            }
        }

        if (!that._cellEditors) {
            that._cellEditors = [];
        }

        if (!that.editing.editRow) {
            that.editing.editCell = cell;
        }

        if (that.editing.commandColumn.visible && !that.editing.editRow) {
            that.editing.isEditing = false;

            that.refresh();

            that.editing.isEditing = true;
        }

        cell.row.element.setAttribute('edit', '');

        that.editing.isEditing = true;
        if (that._selection.selectionRect) {
            that._selection.selectionRect.classList.add('smart-visibility-hidden');
        }

        const appendEditor = (editor) => {
            const element = editor.element;

            if (that.editing.dialog.enabled) {
                that._openEditDialog(cell, editor);
            }
            else {
                if (!cell.element) {
                    cell.createElement();
                }
                cell.element.setAttribute('editor', typeof cell.editor.template === 'string' ? cell.editor.template : 'template');
                cell.element.content.innerHTML = '';
                cell.element.content.appendChild(element);

                if (that.editing.editRow) {
                    cell.element.setAttribute('row-editor', '');
                }
            }

            editor.attach();

            cell.editor.row = cell.row;
            cell.editor.column = cell.column;
            cell.editor.cell = cell;
            cell.editor.instance = editor;
            cell.isEditing = true;
        }

        const modifiedValue = that._cellsUpdatedValues ? that._cellsUpdatedValues[cell.row.id + '_' + cell.column.dataField] : undefined;
        let cellValue = modifiedValue !== undefined ? modifiedValue : cell.value;

        if (cellValue === undefined) {
            cellValue = '';

            const column = cell.column;

            if (column.dataType === 'number' || column.dataType === 'int' || column.dataType === 'float') {
                cellValue = 0;
            }
            else if (column.dataType === 'date') {
                cellValue = new Date();
                cellValue.setTime(0, 0, 0);
            }
        }

        if (!cell.editor) {
            cell.editor = 'input';
        }

        if (typeof cell.editor === 'string') {
            cell.canNotify = false;
            cell.editor = {
                template: cell.editor,
                autoFocus: true
            }
            cell.canNotify = true;
        }

        switch (cell.editor.template) {
            default:
            case 'custom': {
                const editor = that._getCustomCellEditor(cell);

                appendEditor(editor);

                editor.setValue(cellValue);

                break;
            }
            case 'checkBox': {
                const editor = that._getCheckBoxCellEditor(cell);

                appendEditor(editor);

                const value = cellValue === true || cellValue === 1 ? true : false;

                if (cell.template === 'checkBox' && event) {
                    const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.clientX, event.clientY);

                    if (elements[0].classList.contains('smart-input')) {
                        editor.setValue(!value);
                    }
                    else {
                        editor.setValue(value);
                    }
                }
                else {
                    editor.setValue(value);
                }

                break;
            }
            case 'autoComplete': {
                const editor = that._getAutoCompleteCellEditor(cell);

                appendEditor(editor);

                editor.setValue(cellValue);

                if (cell.editor.autoOpen) {
                    editor.element.open();
                }

                break;
            }
            case 'dateTimePicker': {
                const editor = that._getDateTimePickerCellEditor(cell);

                appendEditor(editor);

                editor.setValue(cellValue);

                if (cell.editor.autoOpen) {
                    editor.element.open();
                }
                break;
            }
            case 'textArea':
                {
                    const editor = that._getTextAreaCellEditor(cell);

                    appendEditor(editor);

                    editor.setValue(cellValue);

                    break;
                }
            case 'numberInput':
            case 'input':
                {
                    const editor = cell.editor.template === 'numberInput' ? that._getNumberInputCellEditor(cell) : that._getInputCellEditor(cell);

                    appendEditor(editor);

                    editor.setValue(cellValue);

                    break;
                }
        }

        if (!cell.editor.isInitialized) {
            cell.editor.isInitialized = true;

            if (cell.editor.onInit) {
                cell.editor.onInit(cell.row.index, cell.column.dataField, cell.editor.instance.element);
            }
        }

        if (cell.editor.onRender) {
            cell.editor.onRender(cell.row.index, cell.column.dataField, cell.editor.instance.element);
        }

        if (that.editing.editCell) {
            cell.editor.instance.focus();
        }

        return true;
    }

    _onColumnDoubleClick(column/*, event*/) {
        const that = this;

        that._beginColumnEdit(column);
    }

    _beginColumnEdit(column) {
        const that = this;

        if (that.editing.enabled && that.editing.allowColumnHeaderEdit && column.allowHeaderEdit) {
            if (that.editing.isEditing) {
                that.endEdit();
            }

            that.editing.editColumn = column;

            if (!that._cellEditors) {
                that._cellEditors = [];
            }

            const inputEditor = that._getInputCellEditor({ column: column, row: that.rows[0], editor: { template: 'input' } });
            //const children = column.element.children;

            inputEditor.element.value = column.label;
            inputEditor.focus();
            column.headerEditor = inputEditor;
            column.element.setAttribute('edit', '');
            column.element.label.appendChild(inputEditor.element);
            inputEditor.attach();
            that.editing.isEditing = true;

            that.$.fireEvent('beginEdit', {
                'row': null,
                'column': column,
                'cell': null
            });
        }
    }

    _endColumnEdit(cancelChanges) {
        const that = this;

        if (false === that.editing.isEditing || (that.editing.isEditing && that.editing.editColumn === null)) {
            return false;
        }

        const column = that.editing.editColumn;

        column.canNotify = false;
        column.headerEditor.detach();
        column.headerEditor.element.parentNode.removeChild(column.headerEditor.element);

        if (cancelChanges !== true) {
            column.label = column.headerEditor.getValue();
        }

        column.headerEditor = null;
        that.editing.isEditing = false;
        column.element.removeAttribute('edit');
        column.element.scrollLeft = 0;
        that.editing.editColumn = null;

        column.canNotify = true;
        column.refresh();

        that._recycle();
        return true;
    }

    _cancelColumnEdit() {
        const that = this;

        that._endColumnEdit(true);
    }

    _onCellClick(cell, event) {
        const that = this;

        if (cell.row.addNewRow) {
            if (cell.row.freeze === 'far') {
                that._insertNewRowAfter();
            }
            else {
                that._insertNewRowBefore();
            }

            return;
        }

        if (!that.editing.enabled) {
            return;
        }

        if (that.editing.editColumn) {
            that.endEdit();
            return;
        }

        if (that.editing.commandColumn.visible) {
            if (cell.column.commandColumn) {
                const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.pageX, event.pageY);
                let commandItem = null;

                for (let i = 0; i < elements.length; i++) {
                    if (elements[i].classList.contains('smart-grid-command-item')) {
                        commandItem = elements[i];
                        break;
                    }
                }

                if (!commandItem) {
                    commandItem = cell.element.querySelector('.smart-grid-command-item');
                }

                if (commandItem && !commandItem.classList.contains('smart-hidden')) {
                    const command = commandItem.getAttribute('command');

                    that._applyCommand(command, [cell.row, event]);
                    return;
                }
            }
            else if (that.editing.commandColumn.inline) {
                const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.pageX, event.pageY);
                for (let i = 0; i < elements.length; i++) {
                    if (elements[i].classList.contains('smart-grid-command-item')) {
                        return;
                    }
                }
            }
        }

        if (that.editing.action === 'none' && that.editing.isEditing) {
            let canEndEdit = false;

            if (that.editing.editCell && that.editing.editCell.row !== cell.row) {
                canEndEdit = true;
            }

            if (that.editing.editRow && that.editing.editRow !== cell.row) {
                canEndEdit = true;
            }

            if (that.editing.editColumn) {
                canEndEdit = true;
            }

            if (canEndEdit) {
                that.endEdit();
            }
        }

        if (cell.column.autoGenerated) {
            if (that.editing.allowRowHeaderEdit && cell.column.rowHeaderColumn) {
                if (that.editing.isEditing) {
                    that.endEdit();
                }

                that._beginCellEdit(cell, event);
            }

            return;
        }

        if (that.editing.action !== 'click') {
            return;
        }

        if (that.selection.enabled && !cell.selected && that.selection.mode === 'extended') {
            return;
        }

        if (that.editing.mode === 'cell') {
            const parentCell = cell.parent();

            that.ensureVisible(cell.row.id, cell.column.dataField);

            setTimeout(function () {
                if (parentCell) {
                    that._beginCellEdit(parentCell, event);
                }
                else {
                    that._beginCellEdit(cell, event);
                }

            }, 500);
            //}, 25);
    }
        else if (that.editing.mode === 'row') {
            that._beginRowEdit(cell.row, cell, event);
        }
    }

    _onCellDoubleClick(cell, event) {
        const that = this;

        if (!that.editing.enabled) {
            return;
        }

        if (that.editing.action !== 'doubleClick' || that.editing.isEditing) {
            return;
        }

        if (cell.column.autoGenerated) {
            return;
        }

        if (that.editing.mode === 'cell') {
            that._beginCellEdit(cell, event);
        }
        else if (that.editing.mode === 'row') {
            that._beginRowEdit(cell.row, cell, event);
        }
    }

    _onRowClick(/*index, row, event*/) {
        //const that = this;

    }

    _onRowDoubleClick(/*index, row, event*/) {
        //const that = this;

    }

    /*
    Public API
    */

    beginEdit(id, dataField) {
        const that = this;
        const row = that.rowById[id];

        if (row) {
            that._beginEdit(row, dataField);
        }
    }

    cancelEdit() {
        const that = this;

        if (that.editing.editRow) {
            const cells = that.editing.editRow.cells;

            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                const element = cell.element;

                if (i === 0) {
                    cell.row.element.removeAttribute('edit');
                }

                if (element) {
                    element.removeAttribute('editor');
                    element.removeAttribute('error');
                    element.content.innerHTML = '';
                }

                cell.isEditing = false;
            }

            that.editing.editRow = null;
        }
        else if (that.editing.editCell) {
            that.editing.editCell.row.element.removeAttribute('edit');
            that.editing.editCell.element.removeAttribute('editor');
            that.editing.editCell.element.removeAttribute('error');
            that.editing.editCell.element.content.innerHTML = '';
            that.editing.editCell.isEditing = false;
            that.editing.editCell = null;
        }
        else if (that.editing.editColumn) {
            that._cancelColumnEdit();
        }

        if (that.editing.dialog.visible && that.editing.dialog.enabled) {
            that._dialogEdit.close();
        }

        that.editing.isEditing = false;
        that._recycle(false);


        if (that.editing.commandColumn.visible) {
            that.refresh();
        }

        that.focus();
    }

    deleteRow(id, callback) {
        const that = this;

        const row = that.rowById[id];

        if (!row) {
            return false;
        }

        const command = function (row) {
            if (that.editing.batch === true || (that.editing.batch && that.editing.batch.indexOf('delete') >= 0)) {
                that._batchDeleteRow(row);
            }
            else {
                const index = that.rows.indexOf(row);

                that.rows.splice(index, 1);
            }

            if (callback) {
                callback(row);
            }
        }

        if (that.editing.deleteDialog.enabled) {
            that._openDeleteRowDialog(row, command);
        }
        else {
            command(row);
        }

        return true;
    }

    addUnboundRow(count, position) {
        const that = this;

        if (undefined === count) {
            count = 1;
        }

        if (undefined === position) {
            position = 'far';
        }

        if (!that._nearRowsAdded) {
            that._nearRowsAdded = [];
            that._farRowsAdded = [];
        }

        if (!that._unboundRows) {
            that._unboundRows = [];
        }

        that.beginUpdate();

        for (let i = 0; i < count; i++) {
            const id = Smart.Utilities.Core.createGUID().replace(/-/ig, '');
            const row = new Smart.Grid.Row({ index: -1, unbound: true, id: id, grid: that });

            that.rowById[row.id] = row;

            if (position === 'far') {
                that._farRowsAdded.push(row);
            }
            else {
                that._nearRowsAdded.push(row);
            }

            that._unboundRows.push(row);
        }

        that.endUpdate();
    }

    addNewRow(position) {
        const that = this;

        if (position === 'near') {
            that._insertNewRowBefore();
        }
        else {
            that._insertNewRowAfter();
        }
    }

    endEdit() {
        const that = this;

        let result = false;
        let id = null;

        if (that.editing.dialog.enabled && that.editing.dialog.visible) {
            if (that._dialogEdit) {
                that._dialogEdit.close();
            }
        }

        let cell = null;
        let row = null;
        let column = null;

        if (that.editing.editRow) {
            row = that.editing.editRow;
            id = that.editing.editRow.id;
            result = that._endRowEdit();
        }
        else if (that.editing.editCell) {
            row = that.editing.editCell.row;
            column = that.editing.editCell.column;
            cell = that.editing.editCell;

            id = that.editing.editCell.row.id;
            result = that._endCellEdit();
        }
        else if (that.editing.editColumn) {
            id = null;
            column = that.editing.editColumn;
            result = that._endColumnEdit();
        }

        that._saveUnboundRows(id);

        if (that._selection.selectionRect) {
            that._selection.selectionRect.classList.remove('smart-visibility-hidden');
        }

        that.$.scrollView.scrollTop = 0;

        that.$.fireEvent('endEdit', {
            row: row,
            column: column,
            cell: cell
        });

        return result;
    }

    getBatchEditChanges() {
        const that = this;
        const updatedCells = [];
        const deletedRows = [];
        const addedRows = [];

        for (let key in that._cellsUpdatedValues) {
            const value = that._cellsUpdatedValues[key];
            const rowId = key.substring(0, key.indexOf('_'));
            const columnDataField = key.substring(key.indexOf('_') + 1);

            const row = that.rowById[rowId];
            const cell = row.getCell(columnDataField);

            updatedCells.push({ id: rowId, dataField: columnDataField, oldValue: cell.value, newValue: value });
        }


        if (that._rowsDeleted && that._rowsDeleted.length > 0) {
            for (let i = 0; i < that._rowsDeleted.length; i++) {
                const row = that._rowsDeleted[i];

                deletedRows.push({ id: row.id, data: row });
            }
        }

        if (that._rowsAdded && that._rowsAdded.length > 0) {
            for (let i = 0; i < that._rowsAdded.length; i++) {
                const row = that._rowsAdded[i];

                addedRows.push({ id: row.id, data: row });
            }
        }

        return {
            updated: updatedCells,
            deleted: deletedRows,
            added: addedRows
        };
    }

    saveBatchEdit() {
        const that = this;

        that._saveBatchEdit();
    }

    revertBatchEdit() {
        const that = this;

        that._clearBatchEdit(true);
    }

});
